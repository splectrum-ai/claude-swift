#!/usr/bin/env node

/**
 * Session Management Script - Handle session lifecycle
 * 
 * Manages session initialization, recovery, and termination:
 * - start-initialize: Check session state and handle recovery
 * - start-complete: Complete session initialization workflow
 * - end-session: Handle session termination and archiving
 * 
 * Usage:
 *   session-manage start-initialize
 *   session-manage start-complete  
 *   session-manage end-session [--message "commit message"]
 */

import { promises as fs, existsSync } from 'fs';
import { execSync } from 'child_process';
import path from 'path';
import { getRepoConfig } from './lib/repo-config.js';

/**
 * Audit logging helper
 */
function auditLog(workflow, step, details = '', action = 'step', description = '') {
    try {
        const repoConfig = getRepoConfig();
        const scriptsPath = `${repoConfig.projectRoot}/claude/wow/scripts`;
        execSync(`${scriptsPath}/audit-manage log "${workflow}" "${action}" "${step}" "${details}" "${description}"`, { stdio: 'ignore' });
    } catch (error) {
        const timestamp = new Date().toISOString().replace('T', ' ').substring(0, 19);
        console.log(`[AUDIT] ${timestamp}|${workflow}|${action}|${step}|${details}|${description}`);
    }
}

/**
 * Check if previous session ended cleanly
 */
async function checkPreviousSessionState() {
    const auditPath = 'claude/project/audit/current/current.log';
    
    if (!existsSync(auditPath)) {
        // No current log - check for recent session archives
        const archiveDir = 'claude/project/audit/current';
        try {
            const files = await fs.readdir(archiveDir);
            const sessionFiles = files.filter(f => f.startsWith('session_') && f.endsWith('.log'));
            if (sessionFiles.length > 0) {
                return { status: 'recovered', message: 'Previous session archived but current.log missing - recovered' };
            }
        } catch (err) {
            // Archive directory might not exist
        }
        return { status: 'clean', message: 'No previous session detected' };
    }
    
    try {
        const content = await fs.readFile(auditPath, 'utf8');
        const lines = content.trim().split('\n').filter(line => line.length > 0);
        
        if (lines.length === 0) {
            return { status: 'clean', message: 'Fresh audit log detected' };
        }
        
        // Check last 10 entries for SESSION_END workflow_complete
        const lastEntries = lines.slice(-10);
        const hasCleanSessionEnd = lastEntries.some(line => 
            line.includes('SESSION_END') && line.includes('workflow_complete')
        );
        
        if (hasCleanSessionEnd) {
            return { status: 'clean', message: 'Previous session ended cleanly' };
        }
        
        // No clean SESSION_END found in recent entries
        return { status: 'needs-recovery', message: 'Previous session requires completion - no clean SESSION_END detected' };
        
    } catch (error) {
        return { status: 'error', message: `Could not read audit log: ${error.message}` };
    }
}

/**
 * Handle session start initialization with recovery check
 */
async function startInitialize() {
    const workflow = 'SESSION_START';
    
    auditLog(workflow, 'session_init', '', 'workflow_start', 'Starting session initialization with recovery check');
    
    // Check previous session state
    const sessionState = await checkPreviousSessionState();
    auditLog(workflow, 'recovery_check', sessionState.status, 'step', sessionState.message);
    
    // Return directive if recovery is needed
    if (sessionState.status === 'needs-recovery') {
        console.log('‚ö†Ô∏è  Previous session requires completion - please execute SESSION_END workflow first');
        auditLog(workflow, 'recovery_directive', '', 'step', 'Recovery required - SESSION_END workflow needed');
        return true;
    }
    
    auditLog(workflow, 'initialize_complete', '', 'step', 'Session initialization completed');
    console.log('‚úì Session initialization completed');
    
    return false;
}

/**
 * Complete session start workflow
 */
async function startComplete() {
    const workflow = 'SESSION_START';
    const repoConfig = getRepoConfig();
    const scriptsPath = `${repoConfig.projectRoot}/claude/wow/scripts`;
    
    auditLog(workflow, 'workflow_execution', '', 'step', 'Executing session start workflow');
    
    try {
        // Execute OUTBOX workflow
        console.log('üì¶ Executing OUTBOX workflow...');
        execSync(`${scriptsPath}/outbox-process`, { stdio: 'inherit' });
        auditLog(workflow, 'outbox_complete', '', 'step', 'OUTBOX workflow completed');
        
        // Execute INBOX workflow
        console.log('üì• Executing INBOX workflow...');
        execSync(`${scriptsPath}/inbox-process`, { stdio: 'inherit' });
        auditLog(workflow, 'inbox_complete', '', 'step', 'INBOX workflow completed');
        
        // Execute issue sync
        console.log('üîÑ Executing issue sync...');
        execSync(`${scriptsPath}/issue-manage sync`, { stdio: 'inherit' });
        auditLog(workflow, 'issue_sync_complete', '', 'step', 'Issue sync completed');
        
        // Execute issue triage
        console.log('üìã Executing issue triage...');
        execSync(`${scriptsPath}/issue-manage triage`, { stdio: 'inherit' });
        auditLog(workflow, 'triage_complete', '', 'step', 'Issue triage completed');
        
        auditLog(workflow, 'session_ready', '', 'workflow_complete', 'Session start workflow completed successfully');
        console.log('‚úÖ Session start workflow completed - ready for work!');
        
    } catch (error) {
        auditLog(workflow, 'workflow_error', '', 'step', `Session start workflow failed: ${error.message}`);
        console.error('‚ùå Session start workflow failed:', error.message);
        return false;
    }
    
    return true;
}

/**
 * Handle session end workflow
 */
async function endSession(commitMessage = null) {
    const workflow = 'SESSION_END';
    
    auditLog(workflow, 'session_termination', '', 'workflow_start', 'Starting session termination workflow');
    
    try {
        // Archive session first
        console.log('üìÅ Archiving session...');
        const repoConfig = getRepoConfig();
        const scriptsPath = `${repoConfig.projectRoot}/claude/wow/scripts`;
        execSync(`${scriptsPath}/audit-manage archive-session`, { stdio: 'inherit' });
        
        // Execute COMMIT workflow (includes archived session)
        console.log('üíæ Executing COMMIT workflow...');
        const commitCommand = commitMessage 
            ? `${scriptsPath}/git-manage commit --message "${commitMessage}"`
            : `${scriptsPath}/git-manage commit`;
        execSync(commitCommand, { stdio: 'inherit' });
        
        // Log SESSION_END completion AFTER commit completes (final entry in fresh log)
        console.log('üìù Logging SESSION_END completion...');
        auditLog(workflow, 'session_termination_complete', '', 'workflow_complete', 'SESSION_END workflow completed successfully');
        console.log('‚úÖ SESSION_END completion logged');
        
        console.log('‚úÖ Session end workflow completed');
        
    } catch (error) {
        auditLog(workflow, 'workflow_error', '', 'step', `Session end workflow failed: ${error.message}`);
        console.error('‚ùå Session end workflow failed:', error.message);
        return false;
    }
    
    return true;
}

/**
 * Main function
 */
async function main() {
    try {
        const args = process.argv.slice(2);
        const command = args[0];
        
        if (!command) {
            console.log('Session Management Script - Available commands:');
            console.log('  start-initialize - Check session state and handle recovery');
            console.log('  start-complete - Complete session initialization workflow');
            console.log('  end-session [--message "text"] - Handle session termination and archiving');
            console.log('');
            console.log('Examples:');
            console.log('  session-manage start-initialize');
            console.log('  session-manage start-complete');
            console.log('  session-manage end-session');
            console.log('  session-manage end-session --message "Implement new feature"');
            return;
        }
        
        switch (command) {
            case 'start-initialize':
                const recoveryPerformed = await startInitialize();
                process.exit(recoveryPerformed ? 1 : 0); // Exit code indicates recovery status
                break;
                
            case 'start-complete':
                const success = await startComplete();
                process.exit(success ? 0 : 1);
                break;
                
            case 'end-session':
                // Parse --message parameter
                const messageIndex = args.indexOf('--message');
                const commitMessage = (messageIndex !== -1 && messageIndex + 1 < args.length) 
                    ? args[messageIndex + 1] 
                    : null;
                
                const endSuccess = await endSession(commitMessage);
                process.exit(endSuccess ? 0 : 1);
                break;
                
            default:
                throw new Error(`Unknown command: ${command}`);
        }
        
    } catch (error) {
        console.error(`‚ùå Session management failed: ${error.message}`);
        auditLog('MANUAL', 'error', '', 'workflow_error', `Session management failed: ${error.message}`);
        process.exit(1);
    }
}

// Run if called directly
if (process.argv[1] && process.argv[1].endsWith('session-manage')) {
    main();
}