#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { execSync } from 'child_process';
import { getRepoConfig } from './lib/repo-config.js';

/**
 * Local Issue Management System
 * Handles creation, listing, and management of repository issues
 */

/**
 * Initialize issues structure directly
 */
async function initializeIssuesStructure() {
    console.log('ðŸ”§ Initializing issues structure...');
    
    const issuesDir = 'claude/issues';
    
    if (!fs.existsSync(issuesDir)) {
        console.log('Creating issues directory structure...');
        
        // Create main directories
        fs.mkdirSync(path.join(issuesDir, 'templates'), { recursive: true });
        fs.mkdirSync(path.join(issuesDir, 'unassigned'), { recursive: true });
        
        // Create initial sync.json
        const initialSync = {
            last_sync: null,
            last_github_fetch: null,
            total_issues: 0,
            sync_version: "2.0.0",
            bidirectional_sync: true,
            pulled_from_github: 0,
            pushed_to_github: 0,
            conflicts: 0
        };
        
        fs.writeFileSync(
            path.join(issuesDir, 'sync.json'),
            JSON.stringify(initialSync, null, 2)
        );
        
        console.log('âœ“ Created issues directory structure');
        console.log('âœ“ Created initial sync.json');
    } else {
        console.log('âœ“ Issues structure already exists');
    }
}

/**
 * Sync templates from framework, preserving custom templates
 */
async function syncTemplates() {
    console.log('ðŸ”„ Synchronizing templates with framework...');
    
    const frameworkTemplatesDir = 'claude/wow/templates';
    const localTemplatesDir = 'claude/issues/templates';
    
    if (!fs.existsSync(frameworkTemplatesDir)) {
        console.log('âš ï¸  Framework templates directory not found - using local templates only');
        return;
    }
    
    if (!fs.existsSync(localTemplatesDir)) {
        fs.mkdirSync(localTemplatesDir, { recursive: true });
    }
    
    // Get framework templates
    const frameworkTemplates = fs.readdirSync(frameworkTemplatesDir);
    const mdTemplates = frameworkTemplates.filter(file => file.endsWith('.md'));
    
    // Sync each framework template
    for (const templateFile of mdTemplates) {
        const frameworkPath = path.join(frameworkTemplatesDir, templateFile);
        const localPath = path.join(localTemplatesDir, templateFile);
        
        try {
            const frameworkContent = fs.readFileSync(frameworkPath, 'utf8');
            
            if (fs.existsSync(localPath)) {
                // Check if files are different
                const localContent = fs.readFileSync(localPath, 'utf8');
                
                if (frameworkContent !== localContent) {
                    fs.writeFileSync(localPath, frameworkContent);
                    console.log(`âœ“ Updated template: ${templateFile}`);
                } else {
                    console.log(`âœ“ Template up to date: ${templateFile}`);
                }
            } else {
                // New template from framework
                fs.writeFileSync(localPath, frameworkContent);
                console.log(`âœ“ Added new template: ${templateFile}`);
            }
        } catch (error) {
            console.log(`âœ— Failed to sync template ${templateFile}: ${error.message}`);
        }
    }
    
    // Check for custom templates (preserve them)
    try {
        const localTemplates = fs.readdirSync(localTemplatesDir);
        const localMdTemplates = localTemplates.filter(file => file.endsWith('.md'));
        
        for (const localTemplate of localMdTemplates) {
            const frameworkPath = path.join(frameworkTemplatesDir, localTemplate);
            
            if (!fs.existsSync(frameworkPath)) {
                console.log(`ðŸ“ Custom template preserved: ${localTemplate}`);
            }
        }
    } catch (error) {
        // Local templates directory might not exist yet
    }
}

/**
 * Check if issues structure exists, initialize if needed
 */
async function ensureIssuesInitialized() {
    // Check if issues directory exists
    if (!fs.existsSync('claude/issues')) {
        console.log('ðŸ”§ Issues directory not found. Creating structure...');
        
        try {
            // Initialize issues structure directly
            await initializeIssuesStructure();
            await syncTemplates();
            
            console.log('âœ… Issues structure created successfully');
        } catch (error) {
            throw new Error(`Failed to initialize issues structure: ${error.message}`);
        }
    }
    
    // Check seeding status and offer to seed if not done
    const configPath = 'claude/local/repo-config.json';
    let config = {};
    
    // Load existing config
    if (fs.existsSync(configPath)) {
        try {
            config = JSON.parse(fs.readFileSync(configPath, 'utf8'));
        } catch (error) {
            // Invalid JSON, will recreate
        }
    }
    
    // If not seeded, auto-seed from GitHub
    if (!config.issues_seeded) {
        console.log('ðŸ’¡ Issues structure is ready but not seeded from GitHub.');
        console.log('ðŸŒ± Auto-seeding from GitHub...');
        
        try {
            await seedFromGitHub();
            console.log('âœ… Auto-seeding completed successfully');
        } catch (error) {
            console.warn(`âš ï¸  Auto-seeding failed: ${error.message}`);
            console.log('   You can manually run "issue-manage seed" later');
        }
    }
}

// Get next issue ID
function getNextIssueId() {
    const counterPath = 'claude/issues/.issue-counter';
    let nextId = 1;
    
    if (fs.existsSync(counterPath)) {
        nextId = parseInt(fs.readFileSync(counterPath, 'utf8').trim());
    }
    
    // Update counter
    fs.writeFileSync(counterPath, (nextId + 1).toString());
    
    return nextId.toString().padStart(3, '0');
}

// Create slug from title
function createSlug(title) {
    return title
        .toLowerCase()
        .replace(/[^a-z0-9\s-]/g, '')
        .replace(/\s+/g, '-')
        .replace(/-+/g, '-')
        .replace(/^-|-$/g, '');
}

// Load template
function loadTemplate(type) {
    const templatePath = `claude/issues/templates/${type}.md`;
    console.log(`  Template path: ${path.resolve(templatePath)}`);
    if (!fs.existsSync(templatePath)) {
        throw new Error(`Template not found: ${type}. Available: feature, bug, task`);
    }
    return fs.readFileSync(templatePath, 'utf8');
}

// Extract frontmatter from content
function extractFrontmatter(content) {
    const frontmatterRegex = /^---\n([\s\S]*?)\n---\n/;
    const match = content.match(frontmatterRegex);
    
    if (!match) {
        return {};
    }
    
    const frontmatter = {};
    const lines = match[1].split('\n');
    
    for (const line of lines) {
        const colonIndex = line.indexOf(':');
        if (colonIndex > -1) {
            const key = line.substring(0, colonIndex).trim();
            let value = line.substring(colonIndex + 1).trim();
            
            // Remove quotes if present
            if ((value.startsWith('"') && value.endsWith('"')) || 
                (value.startsWith("'") && value.endsWith("'"))) {
                value = value.substring(1, value.length - 1);
            }
            
            // Parse numbers
            if (!isNaN(value) && value !== '') {
                value = Number(value);
            }
            
            frontmatter[key] = value;
        }
    }
    
    return frontmatter;
}

// Update frontmatter
function updateFrontmatter(content, updates) {
    const frontmatterRegex = /^---\n([\s\S]*?)\n---\n([\s\S]*)$/;
    const match = content.match(frontmatterRegex);
    
    if (!match) {
        throw new Error('Invalid frontmatter format');
    }
    
    const frontmatter = match[1];
    const body = match[2];
    
    // Parse and update frontmatter
    let updatedFrontmatter = frontmatter;
    for (const [key, value] of Object.entries(updates)) {
        const keyRegex = new RegExp(`^${key}:.*$`, 'm');
        const newLine = `${key}: ${typeof value === 'string' ? `"${value}"` : value}`;
        
        if (keyRegex.test(updatedFrontmatter)) {
            updatedFrontmatter = updatedFrontmatter.replace(keyRegex, newLine);
        } else {
            updatedFrontmatter += `\n${newLine}`;
        }
    }
    
    return `---\n${updatedFrontmatter}\n---\n${body}`;
}

// Create new issue
function createIssue(type, title, options = {}) {
    const issueId = getNextIssueId();
    const slug = createSlug(title);
    const filename = `${issueId}-${slug}.md`;
    const filepath = path.join('claude/issues/unassigned', filename);
    
    // Load template
    let content = loadTemplate(type);
    
    // Update frontmatter
    const updates = {
        title: title,
        local_updated_at: new Date().toISOString(),
        ...options
    };
    
    content = updateFrontmatter(content, updates);
    
    // Replace title placeholder in body
    content = content.replace(/\[Feature Name\]/g, title)
                    .replace(/\[Bug Summary\]/g, title)  
                    .replace(/\[Task Name\]/g, title);
    
    // Handle dry-run mode
    if (options.dryRun) {
        console.log(`[DRY RUN] Would create issue ${issueId}: ${title}`);
        console.log(`[DRY RUN] File: ${filepath}`);
        console.log(`[DRY RUN] Type: ${type}`);
        console.log(`[DRY RUN] Content generated (${content.split('\n').length} lines)`);
        
        // Return content for task payload use
        return { issueId, filepath, filename, content };
    }
    
    // Write file
    fs.writeFileSync(filepath, content);
    
    console.log(`âœ“ Created issue ${issueId}: ${title}`);
    console.log(`  File: ${filepath}`);
    console.log(`  Type: ${type}`);
    
    return { issueId, filepath, filename };
}

// Import issue from task file
function importIssue(taskFilePath) {
    if (!fs.existsSync(taskFilePath)) {
        throw new Error(`Task file not found: ${taskFilePath}`);
    }
    
    const taskContent = fs.readFileSync(taskFilePath, 'utf8');
    
    // Extract frontmatter if present
    const frontmatter = extractFrontmatter(taskContent);
    
    // Get title from frontmatter or derive from filename
    let title = frontmatter.title;
    if (!title) {
        // Extract from filename: timestamp_source_task-name.md -> task name
        const basename = path.basename(taskFilePath, '.md');
        const parts = basename.split('_');
        if (parts.length >= 3) {
            title = parts.slice(2).join('_').replace(/-/g, ' ');
        } else {
            title = basename.replace(/-/g, ' ');
        }
    }
    
    // Determine type from frontmatter or default to 'task'
    let type = frontmatter.type || 'task';
    
    // Validate type exists in templates
    const validTypes = ['bug', 'feature', 'task'];
    if (!validTypes.includes(type)) {
        console.warn(`âš ï¸  Unknown issue type '${type}', using 'task' template`);
        type = 'task';
    }
    
    // Extract body content (everything after frontmatter)
    let body = taskContent;
    const frontmatterMatch = taskContent.match(/^---\n[\s\S]*?\n---\n/);
    if (frontmatterMatch) {
        body = taskContent.substring(frontmatterMatch[0].length);
    }
    
    // Create the issue
    const issueId = getNextIssueId();
    const slug = createSlug(title);
    const filename = `${issueId}-${slug}.md`;
    const filepath = path.join('claude/issues/unassigned', filename);
    
    // Load template for proper structure
    console.log(`  Loading template: ${type}`);
    let content = loadTemplate(type);
    
    // Update frontmatter with task data
    const updates = {
        title: title,
        local_updated_at: new Date().toISOString(),
        imported_from: taskFilePath,
        ...frontmatter
    };
    
    content = updateFrontmatter(content, updates);
    
    // Replace template body with task content
    const bodyStartMatch = content.match(/---\n[\s\S]*?\n---\n\n/);
    if (bodyStartMatch) {
        const headerEnd = bodyStartMatch[0].length;
        content = content.substring(0, headerEnd) + body.trim();
    }
    
    // Write the imported issue
    fs.writeFileSync(filepath, content);
    
    console.log(`âœ“ Imported issue ${issueId}: ${title}`);
    console.log(`  File: ${filepath}`);
    console.log(`  Type: ${type}`);
    console.log(`  Source: ${taskFilePath}`);
    
    return { issueId, filepath, filename };
}

// List issues
function listIssues(location = 'all', detailed = false) {
    if (location === 'all') {
        // List all milestone folders plus unassigned
        const issuesDir = 'claude/issues';
        const allDirs = fs.readdirSync(issuesDir, { withFileTypes: true })
            .filter(dirent => dirent.isDirectory())
            .map(dirent => dirent.name)
            .filter(name => !['templates'].includes(name));
        return listIssues(allDirs, detailed);
    }
    
    const locations = Array.isArray(location) ? location : [location];
    
    let totalCount = 0;
    
    for (const loc of locations) {
        const dirPath = `claude/issues/${loc}`;
        if (!fs.existsSync(dirPath)) continue;
        
        const files = fs.readdirSync(dirPath)
            .filter(f => f.endsWith('.md'))
            .sort();
        
        if (files.length > 0) {
            console.log(`\nðŸ“ ${loc.toUpperCase()} (${files.length})`);
            console.log('â”€'.repeat(50));
            
            files.forEach(file => {
                const content = fs.readFileSync(path.join(dirPath, file), 'utf8');
                const frontmatter = extractFrontmatter(content);
                const title = frontmatter.title || 'No title';
                const priority = frontmatter.priority || 'medium';
                const id = file.split('-')[0];
                
                if (detailed) {
                    let summary = frontmatter.short_summary || '';
                    
                    // Fallback to first 80 chars if no short_summary
                    if (!summary) {
                        const body = content.substring(content.indexOf('\n\n', content.indexOf('---', 3)) + 2);
                        const sectionMatch = body.match(/## (?:Problem Statement|Description|Objective)\n(.+?)(?:\n\n|\n##|$)/s);
                        if (sectionMatch) {
                            summary = sectionMatch[1].trim().split('\n')[0];
                        } else {
                            const lines = body.split('\n').filter(line => line.trim() && !line.startsWith('#'));
                            summary = lines[0] || '';
                        }
                        
                        if (summary.length > 80) {
                            summary = summary.substring(0, 77) + '...';
                        }
                    }
                    
                    console.log(`  ${id}: ${title} [${priority}]`);
                    console.log(`      ${summary || 'No description available'}`);
                } else {
                    console.log(`  ${id}: ${title}`);
                }
            });
        }
        
        totalCount += files.length;
    }
    
    console.log(`\nðŸ“Š Total issues: ${totalCount}`);
}

// Show issue details  
function showIssue(issueId) {
    // Find issue file in all milestone folders and unassigned
    const issuesDir = 'claude/issues';
    const locations = fs.readdirSync(issuesDir, { withFileTypes: true })
        .filter(dirent => dirent.isDirectory())
        .map(dirent => dirent.name)
        .filter(name => !['templates'].includes(name));
    
    let found = false;
    
    for (const loc of locations) {
        const dirPath = `claude/issues/${loc}`;
        if (!fs.existsSync(dirPath)) continue;
        
        const files = fs.readdirSync(dirPath)
            .filter(f => f.startsWith(issueId.padStart(3, '0')));
        
        if (files.length > 0) {
            const filepath = path.join(dirPath, files[0]);
            const content = fs.readFileSync(filepath, 'utf8');
            
            console.log(`ðŸ“„ Issue ${issueId} (${loc})`);
            console.log('â•'.repeat(50));
            console.log(content);
            found = true;
            break;
        }
    }
    
    if (!found) {
        console.log(`âŒ Issue ${issueId} not found`);
        process.exit(1);
    }
}

// Basic triage - just list unassigned for now
function triageIssues() {
    console.log('ðŸ“‹ Issue Triage - Unassigned Issues');
    console.log('â•'.repeat(50));
    
    const unassignedPath = 'claude/issues/unassigned';
    if (!fs.existsSync(unassignedPath)) {
        console.log('âœ… No unassigned issues');
        return;
    }
    
    const files = fs.readdirSync(unassignedPath)
        .filter(f => f.endsWith('.md'))
        .sort();
    
    if (files.length === 0) {
        console.log('âœ… No unassigned issues');
        return;
    }
    
    console.log(`Found ${files.length} unassigned issues:`);
    files.forEach(file => {
        const content = fs.readFileSync(path.join(unassignedPath, file), 'utf8');
        const titleMatch = content.match(/title: "(.*)"/);
        const typeMatch = content.match(/type: (.*)/);
        const title = titleMatch ? titleMatch[1] : 'No title';
        const type = typeMatch ? typeMatch[1] : 'unknown';
        const id = file.split('-')[0];
        
        console.log(`  ${id}: [${type}] ${title}`);
    });
    
    console.log('\nðŸ’¡ Manual triage: Move issues to milestone folders as needed');
    console.log('   Future: Automated assignment based on keywords/patterns');
}

// Version milestone validation - must have version prefix
function isVersionMilestone(milestoneTitle) {
    // Must start with 'v' followed by numbers/dots: v1.0, v2.1.3, etc.
    return /^v\d+(\.\d+)*$/i.test(milestoneTitle);
}

// Classify GitHub issue into local template type
function classifyIssueType(githubIssue) {
    const title = githubIssue.title.toLowerCase();
    const labels = githubIssue.labels.map(l => l.name.toLowerCase());
    
    // Check labels first (most reliable)
    if (labels.includes('bug') || labels.includes('fix')) return 'bug';
    if (labels.includes('feature') || labels.includes('enhancement')) return 'feature';
    if (labels.includes('task') || labels.includes('chore')) return 'task';
    
    // Check title keywords
    if (title.includes('bug') || title.includes('fix') || title.includes('error')) return 'bug';
    if (title.includes('feature') || title.includes('add') || title.includes('implement')) return 'feature';
    
    // Default to task for general work
    return 'task';
}

// Seed from GitHub issues
async function seedFromGitHub(options = {}) {
    console.log('ðŸŒ± Seeding local issues from GitHub');
    console.log('â•'.repeat(50));
    
    try {
        // Get repository config
        const config = getRepoConfig();
        const { owner, repo } = config.getRepositoryInfo();
        
        console.log(`Repository: ${owner}/${repo}`);
        
        // Check gh CLI authentication
        try {
            execSync('gh auth status', { stdio: 'pipe' });
        } catch (error) {
            console.log('âŒ GitHub CLI not authenticated');
            console.log('   Run: gh auth login');
            process.exit(1);
        }
        
        // Fetch GitHub issues using gh CLI
        const state = options.state || 'all';
        console.log(`\nðŸ” Fetching ${state} issues from GitHub...`);
        
        let ghCommand = `gh api repos/${owner}/${repo}/issues?state=${state}&per_page=100`;
        const issuesJson = execSync(ghCommand, { encoding: 'utf8' });
        const githubIssues = JSON.parse(issuesJson);
        
        console.log(`ðŸ“¥ Found ${githubIssues.length} GitHub issues`);
        
        if (githubIssues.length === 0) {
            console.log('âœ… No issues to import');
            return;
        }
        
        if (options.dryRun) {
            console.log('\nðŸ” DRY RUN - Preview of issues to import:');
            githubIssues.forEach(issue => {
                const type = classifyIssueType(issue);
                const status = issue.state === 'closed' ? 'closed' : 'open';
                console.log(`  #${issue.number}: [${type}] ${issue.title} (${status})`);
            });
            return;
        }
        
        // Import issues
        let importedCount = 0;
        let skippedCount = 0;
        
        for (const githubIssue of githubIssues) {
            try {
                // Skip closed issues entirely
                if (githubIssue.state === 'closed') {
                    console.log(`â­ Skipping closed issue #${githubIssue.number} (closed issues not seeded)`);
                    skippedCount++;
                    continue;
                }
                
                const type = classifyIssueType(githubIssue);
                const localId = getNextIssueId();
                const slug = createSlug(githubIssue.title);
                const filename = `${localId}-${slug}.md`;
                
                // Determine target directory based on milestone
                let targetDir = 'unassigned';
                let milestoneNote = null;
                
                if (githubIssue.milestone) {
                    if (isVersionMilestone(githubIssue.milestone.title)) {
                        // Valid version milestone - create/use folder
                        targetDir = githubIssue.milestone.title;
                        fs.mkdirSync(`claude/issues/${targetDir}`, { recursive: true });
                    } else {
                        // Non-version milestone - note it but keep in unassigned
                        milestoneNote = githubIssue.milestone.title;
                    }
                }
                
                const filepath = path.join(`claude/issues/${targetDir}`, filename);
                
                // Load template and populate
                let content = loadTemplate(type);
                
                const updates = {
                    title: githubIssue.title,
                    github_id: githubIssue.number,
                    state: githubIssue.state,
                    milestone: githubIssue.milestone ? githubIssue.milestone.title : 'unassigned',
                    labels: JSON.stringify(githubIssue.labels.map(l => l.name)),
                    github_updated_at: githubIssue.updated_at,
                    local_updated_at: new Date().toISOString()
                };
                
                // Add milestone note if non-version milestone
                if (milestoneNote) {
                    updates.github_milestone = milestoneNote;
                }
                
                content = updateFrontmatter(content, updates);
                
                // Replace title in body and add GitHub context
                content = content.replace(/\[Feature Name\]/g, githubIssue.title)
                                .replace(/\[Bug Summary\]/g, githubIssue.title)
                                .replace(/\[Task Name\]/g, githubIssue.title);
                
                // Add GitHub issue body if present
                if (githubIssue.body) {
                    const problemSection = /## (Problem Statement|Description|Objective)/;
                    content = content.replace(problemSection, `$1\n${githubIssue.body}\n\n## Original GitHub Context`);
                }
                
                // Write file
                fs.writeFileSync(filepath, content);
                
                console.log(`âœ“ Imported #${githubIssue.number}: ${githubIssue.title} â†’ ${localId}`);
                importedCount++;
                
            } catch (error) {
                console.log(`âœ— Failed to import #${githubIssue.number}: ${error.message}`);
                skippedCount++;
            }
        }
        
        // Update sync metadata
        const syncData = {
            last_sync: new Date().toISOString(),
            last_github_fetch: new Date().toISOString(),
            total_issues: importedCount,
            sync_version: '1.0.0',
            imported_from_github: true
        };
        
        fs.writeFileSync('claude/issues/sync.json', JSON.stringify(syncData, null, 2));
        
        // Update local config to mark issues as seeded
        const configPath = 'claude/local/repo-config.json';
        let localConfig = {};
        if (fs.existsSync(configPath)) {
            try {
                localConfig = JSON.parse(fs.readFileSync(configPath, 'utf8'));
            } catch (error) {
                // Invalid JSON, will recreate
            }
        }
        
        localConfig.issues_seeded = true;
        localConfig.last_seeded_at = new Date().toISOString();
        fs.writeFileSync(configPath, JSON.stringify(localConfig, null, 2));
        
        console.log('\nðŸ“Š Import Summary:');
        console.log(`  âœ… Imported: ${importedCount}`);
        console.log(`  âŒ Skipped: ${skippedCount}`);
        console.log(`  ðŸ“ Location: claude/issues/`);
        console.log('  ðŸ·ï¸  Config updated: issues_seeded = true');
        console.log('\nðŸ’¡ Next steps:');
        console.log('  - Run: issue sesame triage');
        console.log('  - Organize issues into milestone folders');
        
    } catch (error) {
        console.error(`âŒ Seeding failed: ${error.message}`);
        process.exit(1);
    }
}

// Sync issues bidirectionally with GitHub
async function syncWithGitHub(options = {}) {
    console.log('ðŸ”„ Syncing issues with GitHub (bidirectional)');
    console.log('â•'.repeat(50));
    
    try {
        // Get repository config
        const config = getRepoConfig();
        const { owner, repo } = config.getRepositoryInfo();
        
        // Helper function to get milestone numbers from names
        const getMilestoneNumber = async (milestoneName) => {
            if (!milestoneName || milestoneName === 'unassigned') return null;
            
            try {
                const milestonesJson = execSync(`gh api repos/${owner}/${repo}/milestones`, { encoding: 'utf8' });
                const milestones = JSON.parse(milestonesJson);
                const milestone = milestones.find(m => m.title === milestoneName);
                return milestone ? milestone.number : null;
            } catch (error) {
                console.warn(`âš ï¸  Could not fetch milestones: ${error.message}`);
                return null;
            }
        };
        
        console.log(`Repository: ${owner}/${repo}`);
        
        // Check gh CLI authentication
        try {
            execSync('gh auth status', { stdio: 'pipe' });
        } catch (error) {
            console.log('âŒ GitHub CLI not authenticated');
            console.log('   Run: gh auth login');
            process.exit(1);
        }
        
        // Phase 1: Pull from GitHub
        console.log('\nðŸ“¥ Phase 1: Fetching issues from GitHub...');
        const state = options.state || 'open';
        let ghCommand = `gh api repos/${owner}/${repo}/issues?state=${state}&per_page=100`;
        const issuesJson = execSync(ghCommand, { encoding: 'utf8' });
        const githubIssues = JSON.parse(issuesJson);
        console.log(`Found ${githubIssues.length} GitHub issues`);
        
        // Get all local issues
        console.log('\nðŸ“‚ Phase 2: Reading local issues...');
        const localIssuesMap = new Map();
        const issuesDir = 'claude/issues';
        
        // Scan all directories for issues
        const dirs = fs.readdirSync(issuesDir, { withFileTypes: true })
            .filter(dirent => dirent.isDirectory() && !['templates'].includes(dirent.name))
            .map(dirent => dirent.name);
        
        for (const dir of dirs) {
            const dirPath = path.join(issuesDir, dir);
            
            // Scan main directory files
            const scanDirectory = (scanPath, isClosed = false) => {
                if (!fs.existsSync(scanPath)) return;
                
                const files = fs.readdirSync(scanPath)
                    .filter(f => f.endsWith('.md') && !f.startsWith('.'));
                
                for (const file of files) {
                    const filepath = path.join(scanPath, file);
                    const content = fs.readFileSync(filepath, 'utf8');
                    const frontmatter = extractFrontmatter(content);
                    
                    if (frontmatter.github_id && frontmatter.github_id !== null && frontmatter.github_id !== "null") {
                        localIssuesMap.set(frontmatter.github_id, {
                            filepath,
                            content,
                            frontmatter,
                            directory: dir,
                            isClosed: isClosed,
                            isNew: false
                        });
                    } else if (frontmatter.github_id === null || frontmatter.github_id === "null") {
                        // Track new issues that need creation
                        localIssuesMap.set(`new_${file}`, {
                            filepath,
                            content,
                            frontmatter,
                            directory: dir,
                            isClosed: isClosed,
                            isNew: true
                        });
                    }
                }
            };
            
            // Scan main directory
            scanDirectory(dirPath, false);
            
            // Scan closed/ subdirectory
            const closedPath = path.join(dirPath, 'closed');
            scanDirectory(closedPath, true);
        }
        
        console.log(`Found ${localIssuesMap.size} local issues with GitHub IDs`);
        
        let pulledCount = 0;
        let pushedCount = 0;
        let conflictCount = 0;
        
        // Phase 3: Compare and merge
        console.log('\nðŸ” Phase 3: Comparing timestamps and syncing...');
        
        // Process GitHub issues
        for (const githubIssue of githubIssues) {
            const localIssue = localIssuesMap.get(githubIssue.number);
            
            if (!localIssue) {
                // New issue from GitHub - import it
                console.log(`ðŸ“¥ New issue from GitHub: #${githubIssue.number}`);
                
                if (!options.dryRun) {
                    try {
                        const type = classifyIssueType(githubIssue);
                        const localId = getNextIssueId();
                        const slug = createSlug(githubIssue.title);
                        const filename = `${localId}-${slug}.md`;
                        
                        // Determine target directory based on milestone
                        let targetDir = 'unassigned';
                        let milestoneNote = null;
                        
                        if (githubIssue.milestone) {
                            if (isVersionMilestone(githubIssue.milestone.title)) {
                                // Valid version milestone - create/use folder
                                targetDir = githubIssue.milestone.title;
                                fs.mkdirSync(`claude/issues/${targetDir}`, { recursive: true });
                            } else {
                                // Non-version milestone - note it but keep in unassigned
                                milestoneNote = githubIssue.milestone.title;
                            }
                        }
                        
                        const filepath = path.join(`claude/issues/${targetDir}`, filename);
                        
                        // Load template and populate
                        let content = loadTemplate(type);
                        
                        const updates = {
                            title: githubIssue.title,
                            github_id: githubIssue.number,
                            state: githubIssue.state,
                            milestone: githubIssue.milestone ? githubIssue.milestone.title : 'unassigned',
                            labels: JSON.stringify(githubIssue.labels.map(l => l.name)),
                            github_updated_at: githubIssue.updated_at,
                            local_updated_at: new Date().toISOString()
                        };
                        
                        // Add milestone note if non-version milestone
                        if (milestoneNote) {
                            updates.github_milestone = milestoneNote;
                        }
                        
                        content = updateFrontmatter(content, updates);
                        
                        // Replace template body with GitHub issue body
                        if (githubIssue.body) {
                            const bodyStart = content.lastIndexOf('---') + 4;
                            content = content.substring(0, bodyStart) + '\n' + githubIssue.body + '\n';
                        }
                        
                        fs.writeFileSync(filepath, content);
                        console.log(`  âœ“ Imported #${githubIssue.number} to ${targetDir}/${filename}`);
                        
                    } catch (error) {
                        console.error(`âŒ Failed to import #${githubIssue.number}: ${error.message}`);
                        conflictCount++;
                        continue;
                    }
                }
                
                pulledCount++;
            } else if (!localIssue.isNew) {
                // Sync existing issue with GitHub
                console.log(`ðŸ“¤ Syncing #${githubIssue.number} to GitHub`);
                
                // Extract issue body from local content
                const bodyStart = localIssue.content.indexOf('\n\n', localIssue.content.indexOf('---', 3)) + 2;
                let issueBody = localIssue.content.substring(bodyStart).trim();
                
                // Remove the title line if it exists
                if (issueBody.startsWith('#')) {
                    issueBody = issueBody.substring(issueBody.indexOf('\n') + 1).trim();
                }
                
                // Clean issue body - remove any frontmatter that might have leaked
                issueBody = issueBody.replace(/^---[\s\S]*?---\n*/m, '');
                
                // Filter out problematic shell characters
                issueBody = issueBody
                    .replace(/[`$\\]/g, '') // Remove backticks, dollar signs, backslashes
                    .replace(/\n\s*[-â”‚â”œâ””]/g, '\n-') // Convert tree characters to simple dashes
                    .replace(/[""]/g, '"') // Convert smart quotes to regular quotes
                    .replace(/['']/g, "'") // Convert smart apostrophes to regular ones
                    .replace(/[^\x20-\x7E\n\r\t]/g, ''); // Remove non-printable/extended ASCII
                
                // Determine if issue state needs to change
                const shouldBeClosed = localIssue.isClosed;
                const isCurrentlyOpen = githubIssue.state === 'open';
                const needsStatusChange = shouldBeClosed && isCurrentlyOpen;
                
                // Determine milestone from directory
                const milestoneName = localIssue.directory !== 'unassigned' ? localIssue.directory : null;
                const milestoneNumber = milestoneName ? await getMilestoneNumber(milestoneName) : null;
                const needsMilestoneUpdate = milestoneName && 
                    (!githubIssue.milestone || githubIssue.milestone.title !== milestoneName);
                
                if (!options.dryRun) {
                    try {
                        // Update issue content and metadata
                        let updateCommand = `gh api repos/${owner}/${repo}/issues/${githubIssue.number} -X PATCH ` +
                            `-f body="${issueBody.replace(/"/g, '\\"')}" ` +
                            `-f title="${localIssue.frontmatter.title.replace(/"/g, '\\"')}"`;
                        
                        // Add milestone if needed
                        if (needsMilestoneUpdate && milestoneNumber) {
                            updateCommand += ` -f milestone=${milestoneNumber}`;
                        }
                        
                        // Add state change if needed
                        if (needsStatusChange) {
                            updateCommand += ` -f state="closed"`;
                        }
                        
                        execSync(updateCommand, { stdio: 'pipe' });
                        pushedCount++;
                        
                        // Fetch the updated issue to get the new updated_at timestamp
                        const updatedIssueJson = execSync(
                            `gh api repos/${owner}/${repo}/issues/${githubIssue.number}`,
                            { encoding: 'utf8' }
                        );
                        const updatedIssue = JSON.parse(updatedIssueJson);
                        
                        // Update local github_updated_at with the actual GitHub timestamp
                        const updates = {
                            github_updated_at: updatedIssue.updated_at
                        };
                        const updatedContent = updateFrontmatter(localIssue.content, updates);
                        fs.writeFileSync(localIssue.filepath, updatedContent);
                        
                        if (needsStatusChange) {
                            console.log(`  âœ“ Closed issue #${githubIssue.number}`);
                        }
                        if (needsMilestoneUpdate) {
                            console.log(`  âœ“ Updated milestone to ${milestoneName} for #${githubIssue.number}`);
                        }
                        
                    } catch (error) {
                        console.error(`âŒ Failed to push #${githubIssue.number}: ${error.message}`);
                        conflictCount++;
                    }
                } else {
                    let dryRunActions = [`Update content`];
                    if (needsStatusChange) dryRunActions.push(`Close issue`);
                    if (needsMilestoneUpdate) dryRunActions.push(`Set milestone: ${milestoneName}`);
                    
                    console.log(`  [DRY RUN] Would update GitHub issue #${githubIssue.number}: ${dryRunActions.join(', ')}`);
                    pushedCount++;
                }
            }
        }
        
        // Process new local issues that need creation
        let createdCount = 0;
        console.log('\nðŸ†• Creating new issues on GitHub...');
        
        for (const [key, localIssue] of localIssuesMap) {
            if (localIssue.isNew) {
                console.log(`ðŸ“¤ Creating new issue: ${localIssue.frontmatter.title}`);
                
                // Extract issue body
                const bodyStart = localIssue.content.indexOf('\n\n', localIssue.content.indexOf('---', 3)) + 2;
                let issueBody = localIssue.content.substring(bodyStart).trim();
                
                if (issueBody.startsWith('#')) {
                    issueBody = issueBody.substring(issueBody.indexOf('\n') + 1).trim();
                }
                issueBody = issueBody.replace(/^---[\s\S]*?---\n*/m, '');
                
                // Filter out problematic shell characters
                issueBody = issueBody
                    .replace(/[`$\\]/g, '') // Remove backticks, dollar signs, backslashes
                    .replace(/\n\s*[-â”‚â”œâ””]/g, '\n-') // Convert tree characters to simple dashes
                    .replace(/[""]/g, '"') // Convert smart quotes to regular quotes
                    .replace(/['']/g, "'") // Convert smart apostrophes to regular ones
                    .replace(/[^\x20-\x7E\n\r\t]/g, ''); // Remove non-printable/extended ASCII
                
                const milestoneName = localIssue.directory !== 'unassigned' ? localIssue.directory : null;
                const milestoneNumber = milestoneName ? await getMilestoneNumber(milestoneName) : null;
                
                if (!options.dryRun) {
                    try {
                        // First, create issue with minimal content to avoid shell escaping issues
                        const cleanTitle = localIssue.frontmatter.title.replace(/"/g, '\\"');
                        const shortBody = `Issue created via sync. Full content will be updated.`;
                        
                        let createCommand = `gh api repos/${owner}/${repo}/issues -X POST ` +
                            `-f title="${cleanTitle}" ` +
                            `-f body="${shortBody}"`;
                        
                        if (milestoneNumber) {
                            createCommand += ` -f milestone=${milestoneNumber}`;
                        }
                        
                        const newIssueJson = execSync(createCommand, { encoding: 'utf8' });
                        const newIssue = JSON.parse(newIssueJson);
                        
                        // Now update with full content using gh issue edit (more reliable)
                        try {
                            // Write body to temporary file to avoid shell escaping
                            const tempFile = `/tmp/issue-body-${newIssue.number}.md`;
                            fs.writeFileSync(tempFile, issueBody);
                            
                            execSync(`gh issue edit ${newIssue.number} --body-file "${tempFile}"`, { encoding: 'utf8' });
                            
                            // Clean up temp file
                            fs.unlinkSync(tempFile);
                            
                        } catch (updateError) {
                            console.warn(`  âš ï¸  Created issue #${newIssue.number} but failed to update body: ${updateError.message}`);
                        }
                        
                        // Update local file with GitHub ID
                        const updates = {
                            github_id: newIssue.number,
                            github_updated_at: newIssue.updated_at
                        };
                        const updatedContent = updateFrontmatter(localIssue.content, updates);
                        fs.writeFileSync(localIssue.filepath, updatedContent);
                        
                        console.log(`  âœ“ Created issue #${newIssue.number}`);
                        createdCount++;
                        
                    } catch (error) {
                        console.error(`âŒ Failed to create issue: ${error.message}`);
                        conflictCount++;
                    }
                } else {
                    const actions = [`Create issue: ${localIssue.frontmatter.title}`];
                    if (milestoneName) actions.push(`Milestone: ${milestoneName}`);
                    console.log(`  [DRY RUN] Would ${actions.join(', ')}`);
                    createdCount++;
                }
            }
        }
        
        // Update sync metadata
        const syncData = {
            last_sync: new Date().toISOString(),
            last_github_fetch: new Date().toISOString(),
            total_issues: localIssuesMap.size,
            sync_version: '2.1.0',
            bidirectional_sync: true,
            pulled_from_github: pulledCount,
            pushed_to_github: pushedCount,
            created_on_github: createdCount,
            conflicts: conflictCount
        };
        
        if (!options.dryRun) {
            fs.writeFileSync('claude/issues/sync.json', JSON.stringify(syncData, null, 2));
        }
        
        console.log('\nðŸ“Š Sync Summary:');
        console.log(`  ðŸ“¥ Pulled from GitHub: ${pulledCount}`);
        console.log(`  ðŸ“¤ Pushed to GitHub: ${pushedCount}`);
        console.log(`  ðŸ†• Created on GitHub: ${createdCount}`);
        console.log(`  âš ï¸  Conflicts: ${conflictCount}`);
        console.log(`  ðŸ“ Total local issues: ${localIssuesMap.size}`);
        
        if (options.dryRun) {
            console.log('\nðŸ” DRY RUN - No changes were made');
        }
        
    } catch (error) {
        console.error(`âŒ Sync failed: ${error.message}`);
        process.exit(1);
    }
}

// Close issue or milestone (delete if unassigned, move to closed/ if in milestone)
function closeIssue(identifier) {
    const issuesDir = 'claude/issues';
    
    // Check if it's a milestone name (folder exists)
    const milestonePath = path.join(issuesDir, identifier);
    if (fs.existsSync(milestonePath) && fs.statSync(milestonePath).isDirectory() && 
        !['unassigned', 'templates'].includes(identifier)) {
        
        // Close entire milestone
        const files = fs.readdirSync(milestonePath, { withFileTypes: true })
            .filter(dirent => dirent.isFile() && dirent.name.endsWith('.md'))
            .map(dirent => dirent.name);
        
        if (files.length === 0) {
            console.log(`âœ“ Milestone '${identifier}' already empty`);
            return;
        }
        
        // Create closed directory
        const closedDir = path.join(milestonePath, 'closed');
        if (!fs.existsSync(closedDir)) {
            fs.mkdirSync(closedDir, { recursive: true });
        }
        
        // Move all issue files to closed/
        let movedCount = 0;
        for (const file of files) {
            const sourcePath = path.join(milestonePath, file);
            const targetPath = path.join(closedDir, file);
            
            fs.renameSync(sourcePath, targetPath);
            movedCount++;
        }
        
        console.log(`âœ“ Milestone '${identifier}' closed: ${movedCount} issues moved to closed/`);
        return;
    }
    
    // Handle as individual issue
    const id = identifier.padStart(3, '0');
    let foundPath = null;
    let isUnassigned = false;
    
    // Check unassigned folder
    const unassignedDir = path.join(issuesDir, 'unassigned');
    if (fs.existsSync(unassignedDir)) {
        const files = fs.readdirSync(unassignedDir);
        const unassignedFile = files.find(f => f.startsWith(id + '-'));
        if (unassignedFile) {
            foundPath = path.join(unassignedDir, unassignedFile);
            isUnassigned = true;
        }
    }
    
    // Check milestone folders if not found in unassigned
    if (!foundPath && fs.existsSync(issuesDir)) {
        const folders = fs.readdirSync(issuesDir, { withFileTypes: true })
            .filter(dirent => dirent.isDirectory() && !['unassigned', 'templates'].includes(dirent.name))
            .map(dirent => dirent.name);
            
        for (const folder of folders) {
            const folderPath = path.join(issuesDir, folder);
            const files = fs.readdirSync(folderPath);
            const issueFile = files.find(f => f.startsWith(id + '-'));
            if (issueFile) {
                foundPath = path.join(folderPath, issueFile);
                break;
            }
        }
    }
    
    if (!foundPath) {
        throw new Error(`Issue ${id} not found`);
    }
    
    if (isUnassigned) {
        // Delete unassigned issues
        fs.unlinkSync(foundPath);
        console.log(`âœ“ Issue ${id} deleted (was unassigned)`);
    } else {
        // Move milestone issues to closed subfolder
        const issueDir = path.dirname(foundPath);
        const fileName = path.basename(foundPath);
        const closedDir = path.join(issueDir, 'closed');
        
        // Create closed directory if it doesn't exist
        if (!fs.existsSync(closedDir)) {
            fs.mkdirSync(closedDir, { recursive: true });
        }
        
        const newPath = path.join(closedDir, fileName);
        fs.renameSync(foundPath, newPath);
        
        const milestone = path.basename(issueDir);
        console.log(`âœ“ Issue ${id} closed (moved to ${milestone}/closed/)`);
    }
}

// Helper function to get target version from version config
function getTargetVersion() {
    try {
        const versionConfigPath = 'claude/project/version-config.md';
        if (!fs.existsSync(versionConfigPath)) {
            return null;
        }
        
        const content = fs.readFileSync(versionConfigPath, 'utf8');
        const targetMatch = content.match(/- \*\*TARGET_VERSION\*\*: (.+)/);
        return targetMatch ? `v${targetMatch[1]}` : null;
    } catch (error) {
        console.warn(`âš ï¸  Could not read version config: ${error.message}`);
        return null;
    }
}

// Housekeeping - remove closed milestones that aren't the target version
function housekeeping() {
    const issuesDir = 'claude/issues';
    
    if (!fs.existsSync(issuesDir)) {
        console.log('âŒ No issues directory found');
        return;
    }
    
    // Get target version from config
    const targetVersion = getTargetVersion();
    if (!targetVersion) {
        console.log('âš ï¸  Could not determine target version from config');
        return;
    }
    
    // Get all milestone directories (exclude special folders)
    const milestones = fs.readdirSync(issuesDir, { withFileTypes: true })
        .filter(dirent => dirent.isDirectory() && !['unassigned', 'templates'].includes(dirent.name))
        .map(dirent => dirent.name);
    
    if (milestones.length === 0) {
        console.log('âœ… No milestones found');
        return;
    }
    
    console.log(`ðŸŽ¯ Target version: ${targetVersion}`);
    console.log('ðŸ§¹ Checking milestones for housekeeping...\n');
    
    let removedCount = 0;
    
    for (const milestone of milestones) {
        if (milestone === targetVersion) {
            console.log(`â­ Skipping target milestone: ${milestone}`);
            continue;
        }
        
        const milestonePath = path.join(issuesDir, milestone);
        
        // Check if all issues are in closed/ subfolder
        const files = fs.readdirSync(milestonePath, { withFileTypes: true });
        const issueFiles = files.filter(f => f.isFile() && f.name.endsWith('.md'));
        const closedDir = path.join(milestonePath, 'closed');
        const hasClosedDir = fs.existsSync(closedDir);
        
        if (issueFiles.length === 0 && hasClosedDir) {
            // All issues are closed, safe to remove
            console.log(`ðŸ—‘ Removing closed milestone: ${milestone}`);
            
            // Remove the entire milestone directory
            fs.rmSync(milestonePath, { recursive: true, force: true });
            removedCount++;
        } else if (issueFiles.length > 0) {
            console.log(`â­ Skipping milestone with open issues: ${milestone} (${issueFiles.length} open)`);
        } else {
            console.log(`â­ Skipping empty milestone: ${milestone}`);
        }
    }
    
    console.log(`\nâœ… Housekeeping complete: ${removedCount} closed milestones removed`);
    
    if (removedCount === 0) {
        console.log('ðŸ’¡ No cleanup needed - all milestones are either active or have open issues');
    }
}

// Main CLI
async function main() {
    const args = process.argv.slice(2);
    const command = args[0];
    
    try {
        // Ensure issues structure is initialized before any operation
        if (command) {
            await ensureIssuesInitialized();
        }
        
        switch (command) {
            case 'create':
                if (args.length < 3) {
                    console.log('Usage: issue-manage create <type> <title> [--dry-run]');
                    console.log('Types: feature, bug, task');
                    console.log('Options: --dry-run (generate content without saving)');
                    process.exit(1);
                }
                
                // Parse arguments and options
                const createOptions = {};
                const titleArgs = [];
                
                for (let i = 2; i < args.length; i++) {
                    if (args[i] === '--dry-run') {
                        createOptions.dryRun = true;
                    } else {
                        titleArgs.push(args[i]);
                    }
                }
                
                if (titleArgs.length === 0) {
                    console.log('Error: Title is required');
                    process.exit(1);
                }
                
                const result = createIssue(args[1], titleArgs.join(' '), createOptions);
                
                // In dry-run mode, output the content for potential task payload use
                if (createOptions.dryRun && result.content) {
                    console.log('\n--- GENERATED ISSUE CONTENT ---');
                    console.log(result.content);
                    console.log('--- END CONTENT ---');
                }
                break;
                
            case 'import':
                if (!args[1]) {
                    console.log('Usage: issue-manage import <task-file-path>');
                    process.exit(1);
                }
                importIssue(args[1]);
                break;
                
            case 'list':
                const detailed = args.includes('--detailed') || args.includes('-d');
                const location = args.find(arg => !arg.startsWith('-') && arg !== 'list') || 'all';
                listIssues(location, detailed);
                break;
                
            case 'show':
                if (!args[1]) {
                    console.log('Usage: issue-manage show <issue-id>');
                    process.exit(1);
                }
                showIssue(args[1]);
                break;
                
            case 'triage':
                triageIssues();
                break;
                
            case 'housekeeping':
                housekeeping();
                break;
                
            case 'close':
                if (!args[1]) {
                    console.log('Usage: issue-manage close <issue-id> [issue-id2 issue-id3 ...]');
                    process.exit(1);
                }
                // Handle multiple issue IDs
                const issueIds = args.slice(1).filter(arg => !arg.startsWith('--'));
                for (const issueId of issueIds) {
                    closeIssue(issueId);
                }
                break;
                
            case 'seed':
                const seedOptions = {};
                if (args.includes('--dry-run')) seedOptions.dryRun = true;
                if (args.includes('--state=open')) seedOptions.state = 'open';
                if (args.includes('--state=closed')) seedOptions.state = 'closed';
                await seedFromGitHub(seedOptions);
                break;
                
            case 'sync':
                const syncOptions = {};
                if (args.includes('--dry-run')) syncOptions.dryRun = true;
                if (args.includes('--state=open')) syncOptions.state = 'open';
                if (args.includes('--state=all')) syncOptions.state = 'all';
                await syncWithGitHub(syncOptions);
                break;
                
            default:
                console.log('Local Issue Management');
                console.log('Commands:');
                console.log('  create <type> <title> [--dry-run] - Create new issue (or generate content only)');
                console.log('  import <file>          - Import issue from task file');
                console.log('  list [location] [-d]   - List issues (all/unassigned/v1.0/etc) [--detailed for summaries]');
                console.log('  show <id>              - Show issue details');
                console.log('  close <id|milestone>   - Close issue or milestone (delete if unassigned, archive if milestone)');
                console.log('  triage                 - Review unassigned issues');
                console.log('  housekeeping           - Remove closed milestones (except target version)');
                console.log('  seed [--dry-run] [--state=open|closed] - Import from GitHub');
                console.log('  sync [--dry-run] [--state=open|all] - Bidirectional sync with GitHub');
        }
    } catch (error) {
        console.error(`Error: ${error.message}`);
        process.exit(1);
    }
}

// Run CLI if called directly
if (process.argv[1] && process.argv[1].endsWith('issue-manage')) {
    main().catch(error => {
        console.error(`Fatal error: ${error.message}`);
        process.exit(1);
    });
}

export { createIssue, listIssues, showIssue, triageIssues, getNextIssueId };